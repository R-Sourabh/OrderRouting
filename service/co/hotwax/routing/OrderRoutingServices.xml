<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://moqui.org/xsd/service-definition-3.xsd">

    <service verb="clean" noun="OrderRoutingRun" authenticate="false" transaction-timeout="600">
        <description>Deletes OrderRoutingRun records older than a specified number of days.</description>
        <in-parameters><parameter name="daysToKeep" type="Integer" default="60"/></in-parameters>
        <out-parameters><parameter name="recordsRemoved" type="Long"/></out-parameters>
        <actions>
            <script>
                import org.moqui.context.ExecutionContext
                import org.moqui.entity.EntityCondition
                ExecutionContext ec = context.ec
                Calendar basisCal = ec.user.getCalendarSafe()
                basisCal.add(Calendar.DAY_OF_YEAR, (int) - daysToKeep)
                basisTimestamp = new Timestamp(basisCal.getTimeInMillis())
                recordsRemoved = ec.entity.find("moqui.service.job.ServiceJobRun")
                .condition("startTime", EntityCondition.LESS_THAN, basisTimestamp)
                .disableAuthz().deleteAll()
            </script>
            <log message="Removed ${recordsRemoved} OrderRoutingRun records."/>
        </actions>
    </service>

    <service verb="run" noun="OrderRoutingGroup" transaction-timeout="36000"
             semaphore="wait" semaphore-parameter="productStoreId" semaphore-timeout="3600" semaphore-sleep="120" semaphore-name="OrderRoutingGroup">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
            <parameter name="productStoreId" required="true"/>
            <parameter name="orderId"/>
            <parameter name="shipGroupSeqId"/>
            <!--
            In order to leverage the Service semaphore capabilities provided by the framework, we have chosen to include productStoreId as an input parameter.
            While productStoreId already exists in the OrderRoutingGroup entity,
            opting to use it as an input parameter allows us to seamlessly utilize the framework's existing functionality.

            By incorporating productStoreId as an input parameter,
            we can take advantage of the framework's built-in features without the need for additional custom handling.
            This approach aligns with the established design principles within the framework and ensures a more streamlined and maintainable solution.
            -->
        </in-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="Order routing not found for ${routingGroupId}"/>
            </if>
            <if condition="!orderRoutingGroup.productStoreId">
                <return error="true" message="No productStore associated with routingGroup ${routingGroupId}"/>
            </if>
            <if condition="orderRoutingGroup.productStoreId != productStoreId">
                <return error="true" message="Order routing group [${routingGroupId}] is not associated with productStoreId [${productStoreId}]."/>
            </if>
            <!--TODO: Need to check if we really want to add below check, as we are using service semaphore to avoid simultaneous run -->
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRun" list="routingRuns">
                <econditions>
                    <econdition field-name="productStoreId" from="orderRoutingGroup.productStoreId"/>
                    <econdition field-name="endDate" from="null"/>
                </econditions>
                <order-by field-name="-startDate"/>
            </entity-find>
            <set field="routingRun" from="routingRuns?routingRuns[0]: null"/>
            <if condition="routingRun">
                <return error="true"
                        message="Routing run [${routingRun.routingRunId}] for productStoreId [${orderRoutingGroup.productStoreId}]
                        already in execution since ${routingRun.startDate}"/>
            </if>
            <entity-find entity-name="co.hotwax.order.routing.OrderRouting" list="orderRoutings">
                <econditions>
                    <econdition field-name="routingGroupId" from="routingGroupId"/>
                    <econdition field-name="statusId" value="ROUTING_ACTIVE"/>
                </econditions>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <if condition="!orderRoutings">
                <return type="warning" message="No order routing configuration found for the specified routing group [${routingGroupId}]."/>
            </if>
            <iterate list="orderRoutings" entry="orderRouting">
                <service-call name="create#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                        in-map="[routingGroupId:routingGroupId, orderRoutingId: orderRouting.orderRoutingId,
                                productStoreId: productStoreId, startDate:ec.user.nowTimestamp]"
                        out-map="routingRunResult"/>
                <script>
                    /*
                        Calling a service in a script with ignore-error="true".
                        In this scenario, there is no direct way to identify if the service returned an error.
                        As we want to log the hasError status at the OrderRoutingRun level, to address this we are calling service in script tag
                    */
                    try {
                        ec.service.sync().name("co.hotwax.routing.OrderRoutingServices.run#OrderRouting")
                                .requireNewTransaction(true)
                                .parameters([orderRoutingId: orderRouting.orderRoutingId, orderId: orderId, shipGroupSeqId: shipGroupSeqId])
                                .call()
                    } catch (Throwable e) {
                        ec.logger.error("There is an issue with run#OrderRouting", e)
                    }
                    def routingResult = ec.message.getMessagesString()
                    def hasError = "N"
                    if (ec.message.hasError()) {
                        hasError = "Y"
                        routingResult = ec.message.getErrorsString()
                    }
                    ec.message.clearAll();
                </script>
                <service-call name="update#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                        in-map="[routingRunId:routingRunResult.routingRunId,hasError:hasError, routingResult:routingResult, endDate:ec.user.nowTimestamp]"
                        out-map="routingRunResult"/>
            </iterate>
            <message type="success">Finished order routing for ${orderRoutingGroup.groupName} [${routingGroupId}] routing group.</message>
        </actions>
    </service>

    <service verb="run" noun="OrderRouting" transaction-timeout="36000">
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
            <parameter name="orderId"/>
            <parameter name="shipGroupSeqId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRouting" value-field="orderRouting" cache="true"/>
            <if condition="!orderRouting">
                <return error="true" message="No order routing found for id ${orderRoutingId}"/>
            </if>
            <if condition="!'ROUTING_ACTIVE'.equals(orderRouting.statusId)">
                <return error="true" message="Order routing ${orderRouting.routingName} [${orderRoutingId}] is not active"/>
            </if>
            <entity-find entity-name="co.hotwax.order.routing.OrderFilterCondition" list="orderFilterConditions">
                <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <filter-map-list list="orderFilterConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <filter-map-list list="orderFilterConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRule" list="orderRoutingRules">
                <econditions>
                    <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                    <econdition field-name="statusId" value="RULE_ACTIVE"/>
                </econditions>
                <order-by field-name="sequenceNum"/>
            </entity-find>

            <if condition="!orderRoutingRules">
                <return error="true" message="No routing rule setup for ${orderRoutingId}"/>
            </if>
            <script>
                import org.moqui.entity.EntityListIterator
                import org.moqui.entity.EntityFind;
                import org.moqui.impl.entity.EntityConditionFactoryImpl

                EntityFind find = ec.entity.find("co.hotwax.order.OrderItemsQueue")
                find.condition("itemStatusId", "ITEM_APPROVED")
                find.condition("facilityId", "_NA_")
                find.condition("orderItemCount", org.moqui.entity.EntityCondition.GREATER_THAN, "0")
                if (orderId) {
                    find.condition("orderId", orderId)
                }

                try (EntityListIterator eli = find.iterator()) {
                    while ((entityValue = eli.next()) != null) {
                        try {
                            ruleIterator = orderRoutingRules.iterator()
                            while (ruleIterator.hasNext()) {
                                routingRule = ruleIterator.next()
                                ruleResult = ec.service.sync().name("co.hotwax.routing.OrderRoutingServices.run#OrderRoutingRule")
                                    .requireNewTransaction(true)
                                    .parameters([orderRoutingId: orderRouting.orderRoutingId, routingRuleId: routingRule.routingRuleId,
                                                orderId: entityValue.orderId, shipGroupSeqId: entityValue.shipGroupSeqId])
                                    .call()

                                    ec.logger.info("ruleResult:${ruleResult}")
                            }
                        } catch (Throwable e) {
                            ec.logger.error("There is an issue with run#OrderRoutingRule", e)
                        }
                    }
                } catch (Exception e) {
                    ec.logger.error(e.getMessage())
                }
            </script>
        </actions>
    </service>

    <service verb="run" noun="OrderRoutingRule" transaction-timeout="36000">
        <in-parameters>
            <parameter name="orderRoutingId"/>
            <parameter name="routingRuleId"/>
            <parameter name="orderId"/>
            <parameter name="shipGroupSeqId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="eligibleInventoryItems"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingRule" value-field="orderRoutingRule" cache="true"/>
            <if condition="!orderRoutingRule">
                <return error="true" message="No order routing found for id ${routingRuleId}"/>
            </if>
            <if condition="!'RULE_ACTIVE'.equals(orderRoutingRule.statusId)">
                <return error="true" message="Order routing ${orderRoutingRule.ruleName} [${orderRoutingId}] is not active"/>
            </if>

            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleInvCond" list="inventoryConditions">
                <econdition field-name="routingRuleId" from="routingRuleId"/>
            </entity-find>
            <set field="inventoryFilterMap" from="[:]" />
            <filter-map-list list="inventoryConditions" to-list="inventoryFilterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <iterate list="inventoryFilterConditions" entry="inventoryFilterCondition">
                <script>
                    inventoryFilterMap.put(inventoryFilterCondition.inputParamEnumId, inventoryFilterCondition)
                </script>
            </iterate>
            <filter-map-list list="inventoryConditions" to-list="inventorySortConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <set field="templateLoc" value="component://order-routing/sql/InventorySourceSelector.sql.ftl"/>
            <set field="eligibleInventoryItems" from="[]"/>

            <script>
                Writer writer = new StringWriter()
                ec.resourceFacade.template(templateLoc, writer)
                java.sql.Connection con = ec.getEntity().getConnection(orderRoutingRule.getEntityDefinition().getEntityGroupName())
                con.createStatement().withCloseable({ statement ->
                    statement.executeQuery(writer.toString()).withCloseable({resultSet ->
                        while (resultSet.next()) {
                            eligibleInventoryItems.add([
                                orderId: resultSet.getString('ORDER_ID'),
                                orderItemSeqId: resultSet.getString('ORDER_ITEM_SEQ_ID'),
                                productId: resultSet.getString('PRODUCT_ID'),
                                totalOrderedQty: resultSet.getInt('TOTAL_ORDER_QTY'),
                                itemQty: resultSet.getInt('ITEM_QTY'),
                                routedItemQty: resultSet.getInt('ROUTED_ITEM_QTY'),
                                facilityTypeId: resultSet.getString('FACILITY_TYPE_ID'),
                                facilityId: resultSet.getString('FACILITY_ID'),
                                originPostalCode: resultSet.getString('ORIGIN_POSTAL_CODE'),
                                destinationPostalCode: resultSet.getString('DESTINATION_POSTAL_CODE'),
                                customerPrefShipMethod: resultSet.getString('CUSTOMER_PREF_SHIP_METHOD'),
                                suggestedShipMethod: resultSet.getString('SUGGESTED_SHIP_METHOD'),
                                groundTransitTime: resultSet.getInt('GROUND_TRANSIT_TIME'),
                                shippingZone: resultSet.getString('SHIPPING_ZONE'),
                                rankByOrderAtFacility: resultSet.getString('RANK_BY_ORDER_AT_FACILITY'),
                                rankByItemCnt: resultSet.getString('RANK_BY_ITEM_CNT'),
                                carrierPostalCodeId: resultSet.getString('CARRIER_POSTAL_CODE_ID'),
                                facilityExhausted: resultSet.getString('FACILITY_EXHAUSTED'),
                                lastInventoryCount: resultSet.getString('LAST_INVENTORY_COUNT'),
                                inv: resultSet.getString('INV'),
                                maximumOrderLimit: resultSet.getString('MAXIMUM_ORDER_LIMIT'),
                                lastOrderCount: resultSet.getString('LAST_ORDER_COUNT'),
                                meetSLA: resultSet.getString('MEET_SLA')
                            ])
                        }
                    })
                })
            </script>
        </actions>
    </service>
    <service  verb="run" noun="FacilityAllocation" type="remote-rest" location="${omsBaseUrl}/api/service/orderFulfillmentAllocation?token=${token}" method="post">
        <in-parameters>
            <parameter name="facilityAllocation" type="List"/>
            <parameter name="orderId"/>
            <parameter name="token"/>
        </in-parameters>
    </service>
</services>
