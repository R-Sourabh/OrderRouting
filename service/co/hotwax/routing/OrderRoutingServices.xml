<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://moqui.org/xsd/service-definition-3.xsd">

    <service verb="clean" noun="OrderRoutingRun" authenticate="false" transaction-timeout="600">
        <description>Deletes OrderRoutingRun records older than a specified number of days.</description>
        <in-parameters><parameter name="daysToKeep" type="Integer" default="60"/></in-parameters>
        <out-parameters><parameter name="recordsRemoved" type="Long"/></out-parameters>
        <actions>
            <script>
                import org.moqui.context.ExecutionContext
                import org.moqui.entity.EntityCondition
                ExecutionContext ec = context.ec
                Calendar basisCal = ec.user.getCalendarSafe()
                basisCal.add(Calendar.DAY_OF_YEAR, (int) - daysToKeep)
                basisTimestamp = new Timestamp(basisCal.getTimeInMillis())
                recordsRemoved = ec.entity.find("moqui.service.job.ServiceJobRun")
                .condition("startTime", EntityCondition.LESS_THAN, basisTimestamp)
                .disableAuthz().deleteAll()
            </script>
            <log message="Removed ${recordsRemoved} OrderRoutingRun records."/>
        </actions>
    </service>

    <service verb="run" noun="OrderRoutingGroup" transaction-timeout="36000"
             semaphore="wait" semaphore-parameter="productStoreId" semaphore-timeout="3600" semaphore-sleep="120" semaphore-name="OrderRoutingGroup">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
            <parameter name="productStoreId" required="true"/>
            <!--
            In order to leverage the Service semaphore capabilities provided by the framework, we have chosen to include productStoreId as an input parameter.
            While productStoreId already exists in the OrderRoutingGroup entity,
            opting to use it as an input parameter allows us to seamlessly utilize the framework's existing functionality.

            By incorporating productStoreId as an input parameter,
            we can take advantage of the framework's built-in features without the need for additional custom handling.
            This approach aligns with the established design principles within the framework and ensures a more streamlined and maintainable solution.
            -->
        </in-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="Order routing not found for ${routingGroupId}"/>
            </if>
            <if condition="!orderRoutingGroup.productStoreId">
                <return error="true" message="No productStore associated with routingGroup ${routingGroupId}"/>
            </if>
            <if condition="orderRoutingGroup.productStoreId != productStoreId">
                <return error="true" message="Order routing group [${routingGroupId}] is not associated with productStoreId [${productStoreId}]."/>
            </if>
            <!--TODO: Need to check if we really want to add below check, as we are using service semaphore to avoid simultaneous run -->
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRun" list="routingRuns">
                <econditions>
                    <econdition field-name="productStoreId" from="orderRoutingGroup.productStoreId"/>
                    <econdition field-name="endDate" from="null"/>
                </econditions>
                <order-by field-name="-startDate"/>
            </entity-find>
            <set field="routingRun" from="routingRuns?routingRuns[0]: null"/>
            <if condition="routingRun">
                <return error="true"
                        message="Routing run [${routingRun.routingRunId}] for productStoreId [${orderRoutingGroup.productStoreId}]
                        already in execution since ${routingRun.startDate}"/>
            </if>
            <entity-find entity-name="co.hotwax.order.routing.OrderRouting" list="orderRoutings">
                <econditions>
                    <econdition field-name="routingGroupId" from="routingGroupId"/>
                    <econdition field-name="statusId" value="ROUTING_ACTIVE"/>
                </econditions>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <if condition="!orderRoutings">
                <return type="warning" message="No order routing configuration found for the specified routing group [${routingGroupId}]."/>
            </if>
            <iterate list="orderRoutings" entry="orderRouting">
                <service-call name="create#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                        in-map="[routingGroupId:routingGroupId, orderRoutingId: orderRouting.orderRoutingId,
                                productStoreId: productStoreId, startDate:ec.user.nowTimestamp]"
                        out-map="routingRunResult"/>
                <script>
                    /*
                        Calling a service in a script with ignore-error="true".
                        In this scenario, there is no direct way to identify if the service returned an error.
                        As we want to log the hasError status at the OrderRoutingRun level, to address this we are calling service in script tag
                    */

                    try {
                        ec.service.sync().name("co.hotwax.routing.OrderRoutingServices.run#OrderRouting")
                                .requireNewTransaction(true)
                                .parameters([orderRoutingId: orderRouting.orderRoutingId])
                                .call()
                    } catch (Throwable e) {
                        ec.logger.error("There is an issue with run#OrderRouting", e)
                    }
                    def routingResult = ec.message.getMessagesString()
                    def hasError = "N"
                    if (ec.message.hasError()) {
                        hasError = "Y"
                        routingResult = ec.message.getErrorsString()
                    }
                    ec.message.clearAll();
                </script>
                <service-call name="update#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                        in-map="[routingRunId:routingRunResult.routingRunId,hasError:hasError, routingResult:routingResult, endDate:ec.user.nowTimestamp]"
                        out-map="routingRunResult"/>
            </iterate>
            <message type="success">Finished order routing for ${orderRoutingGroup.groupName} [${routingGroupId}] routing group.</message>
        </actions>
    </service>

    <service verb="run" noun="OrderRouting" transaction-timeout="36000">
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
        </in-parameters>
        <actions>
            <!--
            - Get the  order routing order filter conditions
            - Fetch the orders
            - call the run#orderRutingRule
            -->
        </actions>
    </service>

    <service verb="run" noun="OrderRoutingRule" transaction-timeout="36000">
        <in-parameters>
            <parameter name="routingGroupId"/>
        </in-parameters>
        <actions>
            <!--
            - Get the  order routing rule
            -->
        </actions>
    </service>
</services>
