<?xml version="1.0" encoding="UTF-8"?>
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="https://moqui.org/xsd/service-definition-3.xsd">

    <service verb="clean" noun="OrderRoutingRun" authenticate="false" transaction-timeout="600">
        <description>Deletes OrderRoutingRun records older than a specified number of days.</description>
        <in-parameters><parameter name="daysToKeep" type="Integer" default="60"/></in-parameters>
        <out-parameters><parameter name="recordsRemoved" type="Long"/></out-parameters>
        <actions>
            <script>
                import org.moqui.context.ExecutionContext
                import org.moqui.entity.EntityCondition
                ExecutionContext ec = context.ec
                Calendar basisCal = ec.user.getCalendarSafe()
                basisCal.add(Calendar.DAY_OF_YEAR, (int) - daysToKeep)
                basisTimestamp = new Timestamp(basisCal.getTimeInMillis())
                recordsRemoved = ec.entity.find("moqui.service.job.ServiceJobRun")
                        .condition("startTime", EntityCondition.LESS_THAN, basisTimestamp).disableAuthz().deleteAll()
            </script>
            <log message="Removed ${recordsRemoved} OrderRoutingRun records."/>
        </actions>
    </service>
    <service verb="scheduleNow" noun="OrderRoutingGroup">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="jobRunId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="Order routing group not found for routingGroupId [${routingGroupId}]."/>
            </if>
            <if condition="!orderRoutingGroup.jobName">
                <return error="true" message="Scheduler not configured for order routing group ${orderRoutingGroup.groupName} [${routingGroupId}]."/>
            </if>
            <script>
                jobRunId = ec.service.job(orderRoutingGroup.jobName).run()
            </script>
            <return message="Scheduled job run ${jobRunId} for order routing group ${orderRoutingGroup.groupName} [${routingGroupId}]."/>
        </actions>

    </service>

    <service verb="run" noun="OrderRoutingGroup" transaction-timeout="36000" authenticate="anonymous-all"
             semaphore="wait" semaphore-parameter="productStoreId" semaphore-timeout="3600" semaphore-sleep="60"
             semaphore-ignore="7200" semaphore-name="OrderRoutingGroup">
        <description>
            The action initiates the processing or execution sequence for an Order Routing Group within the system.
            This procedure is crucial for managing and directing orders through the appropriate fulfillment pathways based on predefined criteria and rules set within the Order Routing Group.
            This service is designed to retrieve active order routings for a specified OrderRoutingGroup based on their sequence number.
            It aims to prioritize and organize order processing efficiently, ensuring that orders are routed and fulfilled according to pre-established sequences that optimize logistics, delivery times, and resource allocation.
        </description>
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
            <parameter name="productStoreId" required="true"/>
            <parameter name="orderId"/>
            <parameter name="shipGroupSeqId"/>
            <parameter name="forceRun" type="Boolean" default-value="false"/>
            <!--
            In order to leverage the Service semaphore capabilities provided by the framework, we have chosen to include productStoreId as an input parameter.
            While productStoreId already exists in the OrderRoutingGroup entity,
            opting to use it as an input parameter allows us to seamlessly utilize the framework's existing functionality.

            By incorporating productStoreId as an input parameter,
            we can take advantage of the framework's built-in features without the need for additional custom handling.
            This approach aligns with the established design principles within the framework and ensures a more streamlined and maintainable solution.
            -->
        </in-parameters>
        <actions>
            <!--
                validate the routing group and product store association
            -->
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="Order routing not found for ${routingGroupId}"/>
            </if>
            <if condition="!orderRoutingGroup.productStoreId">
                <return error="true" message="No productStore associated with routing group ${orderRoutingGroup.groupName} [${routingGroupId}]"/>
            </if>
            <if condition="orderRoutingGroup.productStoreId != productStoreId">
                <return error="true" message="Order routing group ${orderRoutingGroup.groupName} [${routingGroupId}] is not associated with productStoreId [${productStoreId}]."/>
            </if>
            <!--TODO: Need to check if we really want to add below check, as we are using service semaphore to avoid simultaneous run -->
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRun" list="routingRuns">
                <econditions>
                    <econdition field-name="productStoreId" from="orderRoutingGroup.productStoreId"/>
                    <econdition field-name="endDate" from="null"/>
                </econditions>
                <order-by field-name="-startDate"/>
            </entity-find>
            <set field="routingRun" from="routingRuns?routingRuns[0]: null"/>
            <!-- If an routing run is in execution, don't run the rule -->
            <if condition="routingRun">
                <if condition="forceRun">
                    <service-call name="update#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                            in-map="[routingRunId:routingRun.routingRunId,hasError:'Y',
                                    routingResult:'Start a new force order routing run, bringing the current routing run to an end',
                                    endDate:ec.user.nowTimestamp]" out-map="routingRunResult"/>
                    <else>
                        <return error="true" message="Routing run [${routingRun.routingRunId}] for productStoreId [${orderRoutingGroup.productStoreId}]
                                already in execution since ${routingRun.startDate}"/>
                    </else>
                </if>

            </if>
            <!-- Get the all active routing for order routing group -->
            <entity-find entity-name="co.hotwax.order.routing.OrderRouting" list="orderRoutings">
                <econditions>
                    <econdition field-name="routingGroupId" from="routingGroupId"/>
                    <econdition field-name="statusId" value="ROUTING_ACTIVE"/>
                </econditions>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <if condition="!orderRoutings">
                <return type="warning" message="No order routing configuration found for the specified routing group ${orderRoutingGroup.groupName} [${routingGroupId}]."/>
            </if>
            <log message="Started order routing for ${orderRoutingGroup.groupName} [${routingGroupId}] routing group."/>
            <iterate list="orderRoutings" entry="orderRouting">
                <service-call name="create#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                        in-map="[routingGroupId:routingGroupId, orderRoutingId: orderRouting.orderRoutingId,
                                productStoreId: productStoreId, startDate:ec.user.nowTimestamp]"
                        out-map="routingRunResult"/>
                <script>
                   /*
                        Calling a service in a script with ignore-error="true".
                        In this scenario, there is no direct way to identify if the service returned an error.
                        As we want to log the hasError status at the OrderRoutingRun level, to address this we are calling service in script tag
                    */
                    try {
                        def orderRoutingResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.run#OrderRouting")
                                .requireNewTransaction(true)
                                .parameters([orderRoutingId: orderRouting.orderRoutingId, orderId: orderId, shipGroupSeqId: shipGroupSeqId])
                                .call()
                    } catch (Throwable e) {
                        ec.logger.error("There is an issue with run#OrderRouting", e)
                    }
                    def routingResult = null
                    def hasError = "N"
                    if (ec.message.hasError()) {
                        hasError = "Y"
                        routingResult = ec.message.getErrorsString()
                    } else {
                        routingResult = ec.message.getMessagesString()
                    }
                    if (routingResult &amp;&amp; routingResult.length() &gt; 255) {
                        routingResult = routingResult.substring(0, 255)
                    }
                    ec.message.clearAll();
                </script>

                <service-call name="update#co.hotwax.order.routing.OrderRoutingRun" transaction="force-new" ignore-error="true"
                        in-map="[routingRunId:routingRunResult.routingRunId,hasError:hasError, routingResult:routingResult, endDate:ec.user.nowTimestamp]"
                        out-map="routingRunResult"/>
            </iterate>
            <message type="success">Finished order routing for ${orderRoutingGroup.groupName} [${routingGroupId}] routing group.</message>
        </actions>
    </service>

    <service verb="run" noun="OldOrderRouting" transaction-timeout="36000">
        <description>
            The service is to streamline the fulfillment process by intelligently routing orders through the system based on predefined conditions and rules.
            This service aims to optimize inventory distribution and order fulfillment efficiency by dynamically applying routing rules to each order's ship group,
            ensuring that inventory allocation and subsequent actions are aligned with business logistics and inventory management strategies.
        </description>
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
            <parameter name="orderId"/>
            <parameter name="shipGroupSeqId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRouting" value-field="orderRouting" cache="true"/>
            <if condition="!orderRouting">
                <return error="true" message="No order routing found for id ${orderRoutingId}"/>
            </if>
            <if condition="!'ROUTING_ACTIVE'.equals(orderRouting.statusId)">
                <return error="true" message="Order routing ${orderRouting.routingName} [${orderRoutingId}] is not active"/>
            </if>
            <entity-find-related-one value-field="orderRouting" relationship-name="co.hotwax.order.routing.OrderRoutingGroup" to-value-field="orderRoutingGroup" cache="true"/>
            <log message="Started order routing ${orderRouting.routingName} [${orderRoutingId}]"/>
            <entity-find entity-name="co.hotwax.order.routing.OrderFilterCondition" list="orderFilterConditions">
                <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <!-- Prepare the filter conditions for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <!-- Prepare the order by for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <if condition="!sortFields">
                <set field="sortFields" from="[[fieldName:'orderDate']]"/>
            </if>
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRule" list="orderRoutingRules">
                <econditions>
                    <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                    <econdition field-name="statusId" value="RULE_ACTIVE"/>
                </econditions>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <if condition="!orderRoutingRules">
                <return error="true" message="No routing rule setup for order routing ${orderRouting.routingName} [${orderRoutingId}]"/>
            </if>
            <script>
                import org.moqui.entity.EntityListIterator
                import org.moqui.entity.EntityFind;
                import org.moqui.impl.entity.EntityConditionFactoryImpl
                import java.time.format.DateTimeFormatter;

                EntityFind orderFind = ec.entity.find("co.hotwax.order.OrderItemsQueue")
                // Prepare the default base condition to get the eligible orderItemShipGroup
                orderFind.condition("productStoreId", orderRoutingGroup?.productStoreId)
                orderFind.condition("itemStatusId", "ITEM_APPROVED")
                orderFind.condition("parentTypeId", "VIRTUAL_FACILITY")
                orderFind.condition("orderItemCount", org.moqui.entity.EntityCondition.GREATER_THAN, "0")

                if (orderId) {
                    orderFind.condition("orderId", orderId)
                    if (shipGroupSeqId) orderFind.condition("shipGroupSeqId", shipGroupSeqId)
                }
                selectFields = ["orderId", "shipGroupSeqId"];
                filterConditions.each { filterCondition ->
                    if ("promiseDaysCutoff".equals(filterCondition.fieldName)) {
                        if (filterCondition.fieldValue) {
                            /*
                            When promiseDaysCutoff is configured, it acts as a constraint that prioritizes order items to be processed and allocated in a way that meets the delivery promise timeframe.
                            The brokering process is executed at the individual order item level rather than at a more aggregated shipGroup level.
                            */
                            selectFields.add("orderItemSeqId")
                            promisedDatetime = ZonedDateTime.now().plusDays(filterCondition.fieldValue as Long).with(java.time.LocalTime.MAX).format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"))
                            orderFind.condition('promisedDatetime', EntityConditionFactoryImpl.stringComparisonOperatorMap.get(filterCondition.operator), promisedDatetime)
                        }
                    } else {
                        orderFind.condition(filterCondition.fieldName, EntityConditionFactoryImpl.stringComparisonOperatorMap.get(filterCondition.operator), filterCondition.fieldValue)
                    }
                }

                sortFields.each { sortField ->
                    orderFind.orderBy(sortField.fieldName)
                }
                orderFind.selectFields(selectFields)
                attemptedCount = orderFind.count()
                ec.logger.info("Fetching order with condition ${orderFind} for routing ${orderRouting.routingName} [${orderRoutingId}]")
                try (EntityListIterator eli = orderFind.iterator()) {
                    while ((shipGroup = eli.next()) != null) {
                        try {
                            ruleIterator = orderRoutingRules.iterator()
                            while (ruleIterator.hasNext()) {
                                routingRule = ruleIterator.next()
                                ruleResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.run#OrderRoutingRule")
                                        .requireNewTransaction(true)
                                        .parameters([routingRuleId: routingRule.routingRuleId,
                                                orderId: shipGroup.orderId, shipGroupSeqId: shipGroup.shipGroupSeqId, orderItemSeqId: shipGroup.orderItemSeqId])
                                        .call()
                                if (!ec.message.hasError()) {
                                    actionResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.eval#OrderRoutingActions")
                                            .requireNewTransaction(true)
                                            .parameters([orderId: shipGroup.orderId, shipGroupSeqId: shipGroup.shipGroupSeqId,orderItemSeqId: shipGroup.orderItemSeqId,
                                                    routingRuleId: routingRule.routingRuleId, suggestedFulfillmentLocations: ruleResult.suggestedFulfillmentLocations])
                                            .call()
                                    if (ec.message.hasError()) {
                                        ec.logger.warn("Ignoring order routing actions errors for ${routingRule.ruleName} [${routingRule.routingRuleId}] " + ec.message.getErrorsString())
                                        ec.message.clearAll()
                                    }
                                    if (!actionResult.runNextRule) {
                                        /* If an order is routed to a facility, all subsequent order routing rule executions should be excluded */
                                        break
                                    }
                                } else {
                                    ec.logger.warn("Ignoring order routing rule errors " + ec.message.getErrorsString())
                                    ec.message.clearAll()
                                }
                            }
                        } catch (Throwable e) {
                            ec.logger.error("There is an issue with run#OrderRoutingRule", e)
                        }
                    }
                } catch (Exception e) {
                    ec.logger.error(e.getMessage())
                }
            </script>
            <return message="Attempted ${attemptedCount} ${selectFields.contains('orderItemSeqId')?'item(s)':'ship group(s)'} for the '${orderRouting.routingName} [${orderRoutingId}] order routing"/>
        </actions>
    </service>

    <service verb="run" noun="OrderRouting" transaction-timeout="36000">
        <description>
            The service is to streamline the fulfillment process by intelligently routing orders through the system based on predefined conditions and rules.
            This service aims to optimize inventory distribution and order fulfillment efficiency by dynamically applying routing rules to each order's ship group,
            ensuring that inventory allocation and subsequent actions are aligned with business logistics and inventory management strategies.
        </description>
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
            <parameter name="orderId"/>
            <parameter name="shipGroupSeqId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRouting" value-field="orderRouting" cache="true"/>
            <if condition="!orderRouting">
                <return error="true" message="No order routing found for id ${orderRoutingId}"/>
            </if>
            <if condition="!'ROUTING_ACTIVE'.equals(orderRouting.statusId)">
                <return error="true" message="Order routing ${orderRouting.routingName} [${orderRoutingId}] is not active"/>
            </if>
            <entity-find-related-one value-field="orderRouting" relationship-name="co.hotwax.order.routing.OrderRoutingGroup" to-value-field="orderRoutingGroup" cache="true"/>
            <log message="Started order routing ${orderRouting.routingName} [${orderRoutingId}]"/>

            <entity-find entity-name="co.hotwax.order.routing.OrderFilterCondition" list="orderFilterConditions">
                <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                <order-by field-name="sequenceNum"/>
                <order-by field-name="createdDate DESC"/>
            </entity-find>
            <!-- Prepare the filter conditions for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <!-- Prepare the order by for the order routing -->
            <filter-map-list list="orderFilterConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <set field="orderSortByList" from="sortFields != null ? sortFields.fieldName:[]" type="List"/>
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRule" list="orderRoutingRules">
                <econditions>
                    <econdition field-name="orderRoutingId" from="orderRoutingId"/>
                    <econdition field-name="statusId" value="RULE_ACTIVE"/>
                </econditions>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <if condition="!orderRoutingRules">
                <return error="true" message="No routing rule setup for order routing ${orderRouting.routingName} [${orderRoutingId}]"/>
            </if>

            <set field="orderTypeId" value="SALES_ORDER"/>
            <set field="productStoreId" from="orderRoutingGroup.productStoreId"/>
            <set field="itemStatusId" value="ITEM_APPROVED"/>
            <set field="orderStatusId" value="ORDER_APPROVED"/>
            <set field="facilityParentTypeId" value="VIRTUAL_FACILITY"/>
            <set field="selectOrderItemSeqId" value="false" type="Boolean"/>
            <set field="orderFilterConditions" from="[]"/>
            <set field="attemptedCount" value="0" type="Integer"/>
            <iterate list="filterConditions" entry="filterCondition">
                <if condition='"promiseDaysCutoff".equals(filterCondition.fieldName)'>
                    <if condition="filterCondition.fieldValue">
                        <!--
                        When promiseDaysCutoff is configured, it acts as a constraint that prioritizes order items to be processed and allocated in a way that meets the delivery promise timeframe.
                        The brokering process is executed at the individual order item level rather than at a more aggregated shipGroup level.
                        -->
                        <set field="selectOrderItemSeqId" value="true" type="Boolean"/>
                        <script>
                            promisedDatetime = java.time.ZonedDateTime.now().plusDays(filterCondition.fieldValue as Long)
                                    .with(java.time.LocalTime.MAX).format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS"))
                        </script>
                        <set field="orderFilterConditions" from="orderFilterConditions + [fieldName: 'promisedDatetime', operator: filterCondition.operator, fieldValue: promisedDatetime]"/>
                    </if>
                <else-if condition='"originFacilityGroupId".equals(filterCondition.fieldName)'>
                    <set field="facilityGroupCondition" from="filterCondition.fieldValue"/>
                </else-if>
                <else-if condition='"productCategoryId".equals(filterCondition.fieldName)'>
                    <set field="productCategoryCondition" from="filterCondition"/>
                </else-if>
                <else>
                    <set field="orderFilterConditions" from="orderFilterConditions + filterCondition"/>
                </else>
                </if>
            </iterate>
            <set field="templateLoc" value="component://order-routing/sql/EligibleOrdersQuery.sql.ftl"/>
            <log message="Fetching order with condition ${orderFilterConditions} for routing ${orderRouting.routingName} [${orderRoutingId}]"/>
            <script>
                    Writer writer = new StringWriter()
                    ec.resourceFacade.template(templateLoc, writer)
                    //ec.logger.info("Eligible orders sql: ${writer}")
                    java.sql.Connection con = ec.getEntity().getConnection(orderRouting.getEntityDefinition().getEntityGroupName())
                    con.createStatement().withCloseable({ statement ->
                        statement.executeQuery(writer.toString()).withCloseable({resultSet ->
                            while (resultSet.next()) {
                                attemptedCount++;
                                def orderItemSeqId=null;
                                def selectedOrderId = resultSet.getString('ORDER_ID');
                                def selectedShipGroupSeqId = resultSet.getString('SHIP_GROUP_SEQ_ID');
                                if (selectOrderItemSeqId) {
                                    orderItemSeqId = resultSet.getString('ORDER_ITEM_SEQ_ID');
                                }
                                ruleIterator = orderRoutingRules.iterator()
                                while (ruleIterator.hasNext()) {
                                    def routingRule = ruleIterator.next()
                                    /**
                                     Note: The use of `requireNewTransaction` causes issues with `ResultSet` objects.
                                     When `requireNewTransaction` is used, the `ResultSet` gets closed prematurely.
                                     To avoid this issue, `ignorePreviousError` is used, which prevents the `ResultSet`
                                     from being closed, allowing for continued data processing without interruption.
                                    */

                                    ruleResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.run#OrderRoutingRule")
                                            .parameters([routingRuleId: routingRule.routingRuleId,
                                                    orderId: selectedOrderId, shipGroupSeqId: selectedShipGroupSeqId, orderItemSeqId: orderItemSeqId])
                                            .ignorePreviousError(true)
                                            .call()
                                    if (ruleResult) {
                                    if (!ec.message.hasError()) {
                                        actionResult = ec.service.sync().name("co.hotwax.order.routing.OrderRoutingServices.eval#OrderRoutingActions")
                                                .parameters([orderId: selectedOrderId, shipGroupSeqId: selectedShipGroupSeqId,orderItemSeqId: orderItemSeqId,
                                                        routingRuleId: routingRule.routingRuleId, suggestedFulfillmentLocations: ruleResult.suggestedFulfillmentLocations])
                                                .ignorePreviousError(true)
                                                .call()
                                        if (ec.message.hasError()) {
                                            ec.logger.warn("Ignoring order routing actions errors for ${routingRule.ruleName} [${routingRule.routingRuleId}] " + ec.message.getErrorsString())
                                            ec.message.clearAll()
                                        }
                                        if (!actionResult?.runNextRule) {
                                            /* If an order is routed to a facility, all subsequent order routing rule executions should be excluded */
                                            break
                                        }
                                    } else {
                                        ec.logger.warn("Ignoring order routing rule errors " + ec.message.getErrorsString())
                                        ec.message.clearAll()
                                    }
                                    }
                                }
                            }
                        })
                    })
            </script>
            <return message="Attempted ${attemptedCount} ${selectOrderItemSeqId?'item(s)':'ship group(s)'} for the '${orderRouting.routingName} [${orderRoutingId}] order routing"/>
        </actions>
    </service>

    <service verb="run" noun="OrderRoutingRule" transaction-timeout="36000">
        <description>
            To dynamically fetch and allocate inventory for order fulfillment based on specific routing rule configurations.
            These rules can encompass various criteria such as geographic location, inventory levels, delivery times, and cost efficiency.
        </description>
        <in-parameters>
            <parameter name="routingRuleId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="shipGroupSeqId" required="true"/>
            <parameter name="orderItemSeqId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="suggestedFulfillmentLocations"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingRule" value-field="orderRoutingRule" cache="true"/>
            <if condition="!orderRoutingRule">
                <return error="true" message="No order routing found for id ${routingRuleId}"/>
            </if>
            <if condition="!'RULE_ACTIVE'.equals(orderRoutingRule.statusId)">
                <return error="true" message="Order routing ${orderRoutingRule.ruleName} [${routingRuleId}] is not active"/>
            </if>
            <log message="Executing order routing rule ${orderRoutingRule.ruleName} [${routingRuleId}] for orderId ${orderId} and shipGroupSeqId ${shipGroupSeqId}"/>

            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleInvCond" list="inventoryConditions">
                <econdition field-name="routingRuleId" from="routingRuleId"/>
                <order-by field-name="sequenceNum"/>
            </entity-find>
            <set field="inventoryFilterMap" from="[:]" />
            <filter-map-list list="inventoryConditions" to-list="filterConditions">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_FILTER"/>
            </filter-map-list>
            <iterate list="filterConditions" entry="filterCondition">
                <script>
                    inventoryFilterMap.put(filterCondition.fieldName, filterCondition)
                </script>
            </iterate>
            <set field="conversionFactor" value="0.000621371"/>
            <set field="measurementSystem" from="inventoryFilterMap?.measurementSystem?.fieldValue" default-value="IMPERIAL"/>
            <if condition="measurementSystem.equals('METRIC')">
                <set field="conversionFactor" value="0.0001"/>
            </if>
            <filter-map-list list="inventoryConditions" to-list="sortFields">
                <field-map field-name="conditionTypeEnumId" value="ENTCT_SORT_BY"/>
            </filter-map-list>
            <order-map-list list="sortFields">
                <order-by field-name="sequenceNum"/>
            </order-map-list>
            <set field="inventorySortByList" from="sortFields != null ? sortFields.fieldName:[]" type="List"/>
            <set field="templateLoc" value="component://order-routing/sql/InventorySourceSelector.sql.ftl"/>
            <set field="suggestedFulfillmentLocations" from="[]"/>
            <script>
                try {
                Writer writer = new StringWriter()
                ec.resourceFacade.template(templateLoc, writer)
                //ec.logger.info("======writer==${writer}==")
                java.sql.Connection con = ec.getEntity().getConnection(orderRoutingRule.getEntityDefinition().getEntityGroupName())
                con.createStatement().withCloseable({ statement ->
                    statement.executeQuery(writer.toString()).withCloseable({resultSet ->
                        while (resultSet.next()) {
                            suggestedFulfillmentLocations.add([
                                orderId: resultSet.getString('ORDER_ID'),
                                orderItemSeqId: resultSet.getString('ORDER_ITEM_SEQ_ID'),
                                //productId: resultSet.getString('PRODUCT_ID'),
                                shipGroupTotalQty: resultSet.getInt('ship_group_total_qty'),
                                itemQty: resultSet.getInt('ITEM_QTY'),
                                routedItemQty: resultSet.getInt('ROUTED_ITEM_QTY'),
                                facilityTypeId: resultSet.getString('FACILITY_TYPE_ID'),
                                facilityId: resultSet.getString('FACILITY_ID'),
                                distance: resultSet.getString('distance')
                            ])
                        }
                    })
                })
                } catch (Exception e) {
                    ec.logger.error("Error executing order routing rule ${orderRoutingRule.ruleName} [${routingRuleId}] : ${e.getMessage()}")
                }
            </script>
        </actions>
    </service>

    <service verb="eval" noun="OrderRoutingActions" transaction-timeout="3600">
        <description>
            To dynamically evaluate and apply actions dictated by order routing rules, ensuring that orders are fulfilled in the most efficient and effective manner.
            This evaluation process determines the optimal steps for order fulfillment based on predefined criteria and actions associated with routing rules.
        </description>
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="shipGroupSeqId" required="true"/>
            <parameter name="orderItemSeqId"/>
            <parameter name="routingRuleId" required="true"/>
            <parameter name="suggestedFulfillmentLocations" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="runNextRule" type="Boolean"/>
            <parameter name="facilityAllocation" type="List"/>
        </out-parameters>
        <actions>
            <set field="runNextRule" value="true" type="Boolean"/>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingRule" value-field="routingRule" cache="true"/>
            <entity-find-related-one value-field="routingRule" relationship-name="co.hotwax.order.routing.OrderRouting" to-value-field="orderRouting" cache="true"/>
            <entity-find-related-one value-field="orderRouting" relationship-name="co.hotwax.order.routing.OrderRoutingGroup" to-value-field="orderRoutingGroup" cache="true"/>
            <entity-find-one entity-name="org.apache.ofbiz.order.order.OrderItemShipGroup" value-field="orderItemShipGroup"/>
            <entity-find entity-name="org.apache.ofbiz.order.order.OrderItem" list="orderItems">
                <econditions>
                    <econdition field-name="orderId" from="orderId"/>
                    <econdition field-name="shipGroupSeqId" from="shipGroupSeqId"/>
                    <econdition field-name="orderItemSeqId" from="orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="statusId" value="ITEM_APPROVED"/>
                </econditions>
            </entity-find>
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleAction" list="ruleActions" cache="true">
                <econditions>
                    <econdition field-name="routingRuleId" from="routingRuleId"/>
                    <econdition field-name="actionValue"  operator="is-not-null"/>
                </econditions>
            </entity-find>
                <script>
                    import java.time.format.DateTimeFormatter;
                    import java.time.ZonedDateTime
                    import java.util.stream.Collectors;
                    import org.moqui.entity.EntityCondition
                    // If a single assignment is preferred, then SQL will return a result only if all the ship group items are available at a single location.
                    def actionMap = ruleActions.collectEntries { [it.actionTypeEnumId, it.actionValue] }

                    facilityAllocation = [];
                    def comments='';
                    def routingRuleName = "${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}] : ${orderRouting.routingName} [${orderRouting.orderRoutingId}] : ${routingRule.ruleName} [${routingRule.routingRuleId}]"
                    def suggestedFacilityIds = suggestedFulfillmentLocations.facilityId as Set
                    if (!routingRule.assignmentEnumId || 'ORA_SINGLE'.equals(routingRule.assignmentEnumId)) {
                        // SQL will not return results if items are not available at a single location.
                        // Additional check to ensure all items are available at a single location.
                        if (!(suggestedFacilityIds.size() == 1)) {
                            comments = "${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}] : Inventory not found at single location for ${routingRule.ruleName} [${routingRule.routingRuleId}]."
                            ec.logger.log(ec.logger.DEBUG_INT, "Inventory not found at single location for ${routingRule.ruleName} [${routingRule.routingRuleId}] for orderId ${orderId} and shipGroupSeqId ${shipGroupSeqId}", null);
                            suggestedFulfillmentLocations = []
                        }
                    }
                    //prepare map for brokered items
                    def queue = null, autoCancelDate = null, brokeredItemsSeqIds = [] ;
                    if (suggestedFulfillmentLocations) {
                        brokeredItemsSeqIds = suggestedFulfillmentLocations.orderItemSeqId;
                        suggestedFacilityIds.each { facilityId->
                            def facilityItems = suggestedFulfillmentLocations.collect()
                            comments = "${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}] : Inventory found at single location for ${routingRule.ruleName} [${routingRule.routingRuleId}]"
                            filterMapList(facilityItems, ["facilityId":facilityId], false)
                            def items = facilityItems.collect { [orderItemSeqId: it.orderItemSeqId] }
                            facilityAllocation.add([facilityId:facilityId, items: items, comments: comments, routingRule: routingRuleName,
                                    routingGroupId: orderRoutingGroup.routingGroupId, orderRoutingId:orderRouting.orderRoutingId, routingRuleId:routingRule.routingRuleId])
                        }
                    }
                    def unfillableItemSeqIds = orderItems.orderItemSeqId.stream().filter(i -> !brokeredItemsSeqIds.contains(i)).collect(Collectors.toList())
                    if (unfillableItemSeqIds) {
                        if (suggestedFulfillmentLocations) {
                            comments = "${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}] : Inventory not found for ${routingRule.ruleName} [${routingRule.routingRuleId}]."
                        }
                        // If unfillable items are found, check for actions.
                        if (actionMap.get('ORA_MV_TO_QUEUE') != null) {
                            queue = actionMap.get('ORA_MV_TO_QUEUE');
                            comments += "Unfillalbe items moved to ${queue}."
                            // If the action is to move to a queue, then there is no need to run the next rule, as all unfillable items will be moved to the queue.
                            runNextRule = false
                        }
                        def clearAutoCancelDate = basicConvert(actionMap.get('ORA_RM_CANCEL_DATE'), 'Boolean') ?: false
                        if (clearAutoCancelDate || actionMap.get('ORA_AUTO_CANCEL_DAYS') != null) {
                            if (!queue) {
                                queue = orderItemShipGroup.facilityId
                            }
                            if (!clearAutoCancelDate &amp;&amp; actionMap.get('ORA_AUTO_CANCEL_DAYS') != null) {
                                comments += "Set the auto cancel date to ${actionMap.get('ORA_AUTO_CANCEL_DAYS')} days from now."
                                autoCancelDate = ZonedDateTime.now().plusDays(actionMap.get('ORA_AUTO_CANCEL_DAYS') as Long).format(DateTimeFormatter.ofPattern("yyyy-MM-dd"))
                            } else if (clearAutoCancelDate) {
                                comments += "Clear the auto cancel date."
                            }
                        }
                        if (queue || autoCancelDate || clearAutoCancelDate) {
                            facilityAllocation.add([facilityId: queue, comments: comments, routingRule:routingRuleName,
                                    items: unfillableItemSeqIds.collect { [orderItemSeqId: it, autoCancelDate: autoCancelDate, clearAutoCancelDate: clearAutoCancelDate]},
                                    routingGroupId: orderRoutingGroup.routingGroupId, orderRoutingId:orderRouting.orderRoutingId, routingRuleId:routingRule.routingRuleId])
                        }
                    } else {
                        //If all items allocated no need to run next rule
                        runNextRule = false
                    }
                </script>
            <if condition="facilityAllocation">
                <log message="Facility allocation for order Id [${orderId}:${shipGroupSeqId}${orderItemSeqId?':' + orderItemSeqId :''}]: ${facilityAllocation}, applied under the '${routingRule.ruleName} [${routingRule.routingRuleId}]' routing rule."/>
                <script>
                    try {
                        outResult = ec.service.sync().name("co.hotwax.order.routing.InventoryReservationServices.run#FacilityAllocation")
                                .requireNewTransaction(true).transactionTimeout(3600)
                                .parameters([orderId: orderId, facilityAllocation: facilityAllocation])
                                .call()
                        if (ec.message.hasError()) {
                            ec.logger.warn("Ignoring facility allocation errors for ${routingRule.ruleName} [${routingRule.routingRuleId}] " + ec.message.getErrorsString())
                            ec.message.clearErrors()
                            ec.message.clearAll()
                        }
                    } catch (Throwable e) {
                        ec.logger.error("Error while facility allocation: ${e.getMessage()}")
                        ec.message.clearErrors()
                        ec.message.clearAll()
                    }
                </script>
                <log message="Facility allocation result: ${outResult}"/>
            <else>
                <log message="No facility allocation found for orderId [${orderId}] for routing rule ${routingRule.ruleName} [${routingRule.routingRuleId}}"/>
            </else>
            </if>
        </actions>
    </service>

    <!-- We can achieve this by OrderRoutingGroup and ServiceJob, as both the entity belongs to different database so we can;t create join between them -->
    <service verb="get" noun="OrderRoutingGroupSchedule">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="schedule" type="Map">
                <auto-parameters entity-name="moqui.service.job.ServiceJob"/>
            </parameter>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="OrderRoutingGroup not found for specified routingGroupId [${routingGroupId}]."/>
            </if>
            <if condition="!orderRoutingGroup.jobName">
                <return message="No schedule found for order routing group ${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}]/"/>
            </if>
            <entity-find-one entity-name="moqui.service.job.ServiceJob" value-field="serviceJob">
                <field-map field-name="jobName" from="orderRoutingGroup.jobName"/>
            </entity-find-one>
            <if condition="serviceJob">
                <script>
                    schedule = serviceJob.getMap()
                    try {
                    schedule.cronDescription = org.moqui.impl.service.ScheduledJobRunner.getCronDescription(schedule.cronExpression, ec.user.getLocale(), true)
                    cronExecutionTime = org.moqui.impl.service.ScheduledJobRunner.getExecutionTime(schedule.cronExpression)
                    nextExecutionTime = cronExecutionTime.nextExecution(java.time.ZonedDateTime.now()).orElse(null)
                    if (nextExecutionTime != null) {
                        schedule.nextExecutionDateTime = nextExecutionTime.toInstant().toEpochMilli()
                    }
                    schedule.executionTimeZone = TimeZone.getDefault().getID()
                    } catch (Exception e) {
                        ec.logger.error("Error getting cron description: ${e.getMessage()}")
                        schedule.cronDescription = e.getMessage()
                    }
                </script>
            </if>
        </actions>
    </service>
    <service verb="store" noun="OrderRoutingGroupSchedule">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
            <auto-parameters entity-name="moqui.service.job.ServiceJob" include="nonpk">
                <exclude field-name="description"/>
                <exclude field-name="serviceName"/>
            </auto-parameters>
        </in-parameters>
        <out-parameters>
            <parameter name="jobName"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup"/>
            <if condition="!orderRoutingGroup">
                <return error="true" message="OrderRoutingGroup not found for specified routingGroupId [${routingGroupId}]."/>
            </if>
            <if condition="!orderRoutingGroup.productStoreId">
                <return message="No productStore associated with routing group ${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}]/"/>
            </if>
            <if condition="cronExpression">
                <script>
                    try {
                        cronDescription = org.moqui.impl.service.ScheduledJobRunner.getCronDescription(cronExpression, ec.user.getLocale(), false)
                    } catch (Exception e) {
                        ec.logger.error("Error getting cron description: ${e.getMessage()}")
                        ec.message.addError("Error getting cron description: ${e.getMessage()}")
                        return
                    }
                </script>
            </if>
            <if condition="orderRoutingGroup.jobName">
                <entity-find-one entity-name="moqui.service.job.ServiceJob" value-field="serviceJob">
                    <field-map field-name="jobName" from="orderRoutingGroup.jobName"/>
                </entity-find-one>
            </if>
            <set field="description" value="Service job for order routing group ${orderRoutingGroup.groupName} [${orderRoutingGroup.routingGroupId}]"/>
            <set field="serviceName" value="co.hotwax.order.routing.OrderRoutingServices.run#OrderRoutingGroup"/>
            <if condition="!serviceJob">
                <if condition="!paused">
                    <set field="paused" value="N"/>
                </if>
                <set field="jobName" value="Order_Routing_Group_${orderRoutingGroup.routingGroupId}"/>
                <service-call name="create#moqui.service.job.ServiceJob" in-map="context + [jobName: jobName]" out-map="context"/>
                <!-- Set the JobName in orderRoutingGroup entity -->
                <set field="orderRoutingGroup.jobName" from="jobName"/>
                <service-call name="update#co.hotwax.order.routing.OrderRoutingGroup" in-map="[routingGroupId:routingGroupId, jobName: jobName]"/>
                <!--
                    For order routing scheduling we need only two parameters
                    - productStoreId - This is to ensure only one routing is in execution for an ProductStore
                    - routingGroupId
                 -->
                <service-call name="create#moqui.service.job.ServiceJobParameter" in-map="[jobName: jobName, parameterName: 'routingGroupId', parameterValue: routingGroupId]"/>
                <service-call name="create#moqui.service.job.ServiceJobParameter" in-map="[jobName: jobName, parameterName: 'productStoreId', parameterValue: orderRoutingGroup.productStoreId]"/>
                <return message="Order routing group schedule has been created successfully."/>
            <else>
                <service-call name="update#moqui.service.job.ServiceJob" in-map="context + [jobName: serviceJob.jobName]" out-map="context"/>
                <return message="Order routing group schedule has been updated successfully."/>
            </else>
            </if>
        </actions>
    </service>

<!-- Cloning services -->
    <service verb="clone" noun="OrderRoutingGroup">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
            <parameter name="newGroupName"/>
            <parameter name="sequenceNum">
                <description>Order routing group sequence. By default, it will be added as the last one. </description>
            </parameter>
            <parameter name="copyOrderRoutings" default-value="true" type="Boolean">
                <description>Parameter to check if the Order routing needs to be cloned.</description>
            </parameter>
            <parameter name="copyOrderRoutingRules" default-value="true" type="Boolean">
                <description>Parameter to check if the Order routing rule needs to be cloned, works only if copyOrderRoutings set to true.</description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="newRoutingGroupId" required="true"/>
        </out-parameters>
    <actions>
        <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup" cache="false"/>
        <if condition="!orderRoutingGroup">
            <log level="error" message="No orderRoutingGroup found for id ${routingGroupId}"/>
            <return error="true" type="warning"/>
        </if>
        <!-- Create new OrderRoutingGroup -->
        <if condition="!sequenceNum">
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingGroup" list="orderRoutingGroups">
                <econdition field-name="productStoreId" from="orderRoutingGroup.productStoreId"/>
                <econdition field-name="sequenceNum" operator="is-not-null"/>
                <order-by field-name="-sequenceNum"/>
            </entity-find>
            <set field="sequenceNum" from="orderRoutingGroups?(orderRoutingGroups.first().sequenceNum +1 ): 1"/>
        </if>
        <set field="newRoutingGroup" from="orderRoutingGroup.getValueMap()" />
        <script>
            newRoutingGroup.remove("routingGroupId");
            newRoutingGroup.remove("jobName");
            newRoutingGroup.remove("lastUpdatedStamp");
        </script>
        <set field="newRoutingGroup.groupName" from="newGroupName" default-value="copy of ${orderRoutingGroup.groupName}"/>
        <set field="newRoutingGroup.sequenceNum" from="sequenceNum"/>
        <set field="newRoutingGroup.createdByUser" from="ec.user.getUsername()"/>
        <set field="newRoutingGroup.createdDate" from="ec.user.nowTimestamp"/>
        <set field="newRoutingGroup.lastModifiedDate" from="ec.user.nowTimestamp"/>
        <service-call name="create#co.hotwax.order.routing.OrderRoutingGroup" in-map="newRoutingGroup" out-map="resultMap"/>
        <set field="newRoutingGroupId" from="resultMap.routingGroupId"/>

        <!-- Get associated OrderRouting -->
        <if condition="copyOrderRoutings">
            <entity-find entity-name="co.hotwax.order.routing.OrderRouting" list="orderRoutings">
                <econdition field-name="routingGroupId"/>
            </entity-find>
            <iterate list="orderRoutings" entry="orderRouting">
                <service-call name="co.hotwax.order.routing.OrderRoutingServices.clone#OrderRouting"
                        in-map="[orderRoutingId: orderRouting.orderRoutingId, newRoutingGroupId:newRoutingGroupId, copyOrderRoutingRules: copyOrderRoutingRules, sequenceNum:orderRouting.sequenceNum]" />
            </iterate>
        </if>
    </actions>
    </service>
    <service verb="clone" noun="OrderRouting">
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
            <parameter name="newRoutingGroupId" required="true"/>
            <parameter name="copyOrderRoutingRules" default-value="true" type="Boolean">
                <description>Parameter to check if the Order routing rule needs to be cloned.</description>
            </parameter>
            <parameter name="newRoutingName"/>
            <parameter name="sequenceNum">
                <description>Order routing group sequence. By default, it will be added as the last one. </description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="newOrderRoutingId" required="true"/>
        </out-parameters>
        <actions>
            <!-- Create new OrderRouting -->
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRouting" value-field="orderRouting" cache="false"/>
            <if condition="!orderRouting">
                <log level="error" message="No orderRouting found for id ${orderRoutingId}"/>
                <return error="true" type="warning"/>
            </if>
            <if condition="!sequenceNum">
                <entity-find entity-name="co.hotwax.order.routing.OrderRouting" list="orderRoutings">
                    <econdition field-name="routingGroupId" from="orderRouting.routingGroupId"/>
                    <econdition field-name="sequenceNum" operator="is-not-null"/>
                    <order-by field-name="-sequenceNum"/>
                </entity-find>
                <set field="sequenceNum" from="orderRoutings?(orderRoutings.first().sequenceNum +1): 1"/>
            </if>
            <set field="newOrderRouting" from="orderRouting.getValueMap()" />
            <script>
                newOrderRouting.remove("orderRoutingId");
                newOrderRouting.remove("lastUpdatedStamp");
            </script>
            <set field="newOrderRouting.statusId" value="ROUTING_DRAFT"/>
            <set field="newOrderRouting.routingGroupId" from="newRoutingGroupId"/>
            <set field="newOrderRouting.routingName" from="newRoutingName" default-value="${orderRouting.routingName}"/>
            <set field="newOrderRouting.sequenceNum" from="sequenceNum"/>
            <set field="newOrderRouting.createdDate" from="ec.user.nowTimestamp"/>
            <set field="newOrderRouting.createdByUser" from="ec.user.getUsername()"/>
            <service-call name="create#co.hotwax.order.routing.OrderRouting" in-map="newOrderRouting" out-map="resultMap"/>
            <set field="newOrderRoutingId" from="resultMap.orderRoutingId"/>

            <!-- clone#OrderFilterCondition -->
            <entity-find entity-name="co.hotwax.order.routing.OrderFilterCondition" list="orderFilterConditions">
                <econdition field-name="orderRoutingId"/>
            </entity-find>
            <iterate list="orderFilterConditions" entry="orderFilterCondition">
                <set field="newOrderFilterCondition" from="orderFilterCondition.getValueMap()" />
                <set field="newOrderFilterCondition.orderRoutingId" from="newOrderRoutingId"/>
                <set field="newOrderFilterCondition.createdDate" from="ec.user.nowTimestamp"/>
                <script>
                    newOrderFilterCondition.remove("conditionSeqId");
                    newOrderFilterCondition.remove("lastUpdatedStamp");
                </script>
                <service-call name="create#co.hotwax.order.routing.OrderFilterCondition" in-map="newOrderFilterCondition"/>
            </iterate>

            <!-- Get associated OrderRoutingRule -->
            <if condition="copyOrderRoutingRules">
                <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRule" list="orderRoutingRules">
                    <econdition field-name="orderRoutingId"/>
                </entity-find>
                <iterate list="orderRoutingRules" entry="orderRoutingRule">
                    <service-call name="co.hotwax.order.routing.OrderRoutingServices.clone#OrderRoutingRule"
                            in-map="[routingRuleId: orderRoutingRule.routingRuleId, newOrderRoutingId: newOrderRoutingId, sequenceNum:orderRoutingRule.sequenceNum]" />
                </iterate>
            </if>
        </actions>
    </service>
    <service verb="clone" noun="OrderRoutingRule">
        <in-parameters>
            <parameter name="routingRuleId" required="true"/>
            <parameter name="newOrderRoutingId" required="true"/>
            <parameter name="newRuleName"/>
            <parameter name="sequenceNum">
                <description>Order routing group sequence. By default, it will be added as the last one. </description>
            </parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="newRoutingRuleId" required="true"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingRule" value-field="orderRoutingRule" cache="false"/>
            <if condition="!orderRoutingRule">
                <log level="error" message="No order routing rule found for id ${routingRuleId}"/>
                <return error="true" type="warning"/>
            </if>
            <if condition="!sequenceNum">
                <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRule" list="orderRoutingRules">
                    <econdition field-name="orderRoutingId" from="orderRoutingRule.orderRoutingId"/>
                    <econdition field-name="sequenceNum" operator="is-not-null"/>
                    <order-by field-name="-sequenceNum"/>
                </entity-find>
                <set field="sequenceNum" from="orderRoutingRules?(orderRoutingRules.first().sequenceNum +1) : 1"/>
            </if>
            <!-- Create new OrderRoutingRule -->
            <set field="newOrderRoutingRule" from="orderRoutingRule.getValueMap()" />
            <script>
                newOrderRoutingRule.remove("routingRuleId");
                newOrderRoutingRule.remove("lastUpdatedStamp");
            </script>
            <set field="newOrderRoutingRule.statusId" value="RULE_DRAFT"/>
            <set field="newOrderRoutingRule.orderRoutingId" from="newOrderRoutingId"/>
            <set field="newOrderRoutingRule.ruleName" from="newRuleName" default-value="${orderRoutingRule.ruleName}"/>
            <set field="newOrderRoutingRule.sequenceNum" from="sequenceNum"/>
            <set field="newOrderRoutingRule.createdDate" from="ec.user.nowTimestamp"/>
            <set field="newOrderRoutingRule.createdByUser" from="ec.user.getUsername()"/>
            <service-call name="create#co.hotwax.order.routing.OrderRoutingRule" in-map="newOrderRoutingRule" out-map="resultMap"/>
            <set field="newRoutingRuleId" from="resultMap.routingRuleId"/>
            <!-- clone#OrderRoutingRuleInvCond -->
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleInvCond" list="orderRoutingRuleInvCondList">
                <econdition field-name="routingRuleId"/>
            </entity-find>
            <iterate list="orderRoutingRuleInvCondList" entry="orderRoutingRuleInvCond">
                <set field="newOrderRoutingRuleInvCond" from="orderRoutingRuleInvCond.getValueMap()" />
                <set field="newOrderRoutingRuleInvCond.routingRuleId" from="newRoutingRuleId"/>
                <set field="newOrderRoutingRuleInvCond.createdDate" from="ec.user.nowTimestamp"/>
                <script>
                    newOrderRoutingRuleInvCond.remove("conditionSeqId");
                    newOrderRoutingRuleInvCond.remove("lastUpdatedStamp");
                </script>
                <service-call name="create#co.hotwax.order.routing.OrderRoutingRuleInvCond" in-map="newOrderRoutingRuleInvCond"/>
            </iterate>

            <!-- clone#OrderRoutingRuleAction -->
            <entity-find entity-name="co.hotwax.order.routing.OrderRoutingRuleAction" list="orderRoutingRuleActionList">
                <econdition field-name="routingRuleId"/>
            </entity-find>
            <iterate list="orderRoutingRuleActionList" entry="orderRoutingRuleAction">
                <set field="newOrderRoutingRuleAction" from="orderRoutingRuleAction.getValueMap()" />
                <set field="newOrderRoutingRuleAction.routingRuleId" from="newRoutingRuleId"/>
                <set field="newOrderRoutingRuleAction.createdDate" from="ec.user.nowTimestamp"/>
                <script>
                    newOrderRoutingRuleAction.remove("actionSeqId");
                    newOrderRoutingRuleAction.remove("lastUpdatedStamp");
                </script>
                <service-call name="create#co.hotwax.order.routing.OrderRoutingRuleAction" in-map="newOrderRoutingRuleAction"/>
            </iterate>
        </actions>
    </service>
    <!-- Danger Zone-->
    <service verb="delete" noun="OrderRoutingGroup">
        <in-parameters>
            <parameter name="routingGroupId" required="true"/>
        </in-parameters>
        <actions>
            <if condition="!ec.user.hasPermission('DELETE_ORDER_ROUTE')">
                <return error="true" message="User does not have permission to delete order routing group."/>
            </if>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingGroup" value-field="orderRoutingGroup" cache="false"/>
            <if condition="!orderRoutingGroup">
                <log level="error" message="No orderRoutingGroup found for id ${routingGroupId}"/>
                <return error="true" type="warning"/>
            </if>
            <entity-find-one entity-name="moqui.service.job.ServiceJob" value-field="serviceJob">
                <field-map field-name="jobName" from="orderRoutingGroup.jobName"/>
            </entity-find-one>
            <if condition="serviceJob">
                <service-call name="update#moqui.service.job.ServiceJob" in-map="[jobName: orderRoutingGroup.jobName, thruDate: ec.user.nowTimestamp, paused: 'Y']" disable-authz="true"/>
            </if>
            <script>
                orderRoutingGroup.deleteWithCascade(null , ['co.hotwax.order.routing.OrderRouting', 'co.hotwax.order.routing.OrderFilterCondition', 'co.hotwax.order.routing.OrderRoutingRule', 'co.hotwax.order.routing.OrderRoutingRuleInvCond', 'co.hotwax.order.routing.OrderRoutingRuleAction'] as Set)
            </script>
            <return message="Order routing group ${orderRoutingGroup.groupName?:''} [${routingGroupId}] delete successfully."/>
        </actions>
    </service>
    <service verb="delete" noun="OrderRouting">
        <in-parameters>
            <parameter name="orderRoutingId" required="true"/>
        </in-parameters>
        <actions>
            <if condition="!ec.user.hasPermission('DELETE_ORDER_ROUTE')">
                <return error="true" message="User does not have permission to delete order routing."/>
            </if>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRouting" value-field="orderRouting" cache="false"/>
            <if condition="!orderRouting">
                <log level="error" message="No order routing found for id ${orderRouting}"/>
                <return error="true" type="warning"/>
            </if>
            <script>
                orderRouting.deleteWithCascade(null, ['co.hotwax.order.routing.OrderFilterCondition', 'co.hotwax.order.routing.OrderRoutingRuleInvCond', 'co.hotwax.order.routing.OrderRoutingRuleAction', 'co.hotwax.order.routing.OrderRoutingRule'] as Set)
            </script>
            <return message="Order routing ${orderRouting.routingName?:''} [${orderRoutingId}] delete successfully."/>
        </actions>
    </service>
    <service verb="delete" noun="OrderRoutingRule">
        <in-parameters>
            <parameter name="routingRuleId" required="true"/>
        </in-parameters>
        <actions>
            <if condition="!ec.user.hasPermission('DELETE_ORDER_ROUTE')">
                <return error="true" message="User does not have permission to delete order routing rule."/>
            </if>
            <entity-find-one entity-name="co.hotwax.order.routing.OrderRoutingRule" value-field="orderRoutingRule" cache="false"/>
            <if condition="!orderRoutingRule">
                <log level="error" message="No order routing rule found for id ${orderRouting}"/>
                <return error="true" type="warning"/>
            </if>
            <script>
                orderRoutingRule.deleteWithCascade(null, ['co.hotwax.order.routing.OrderRoutingRuleInvCond', 'co.hotwax.order.routing.OrderRoutingRuleAction'] as Set)
            </script>
            <return message="Order routing rule ${orderRoutingRule.ruleName?:''} [${routingRuleId}] delete successfully."/>
        </actions>
    </service>
</services>
